// Generated by LiveScript 1.5.0
(function(){
  var ref$, isType, map, filter, foldl, join, flatten, keys, empty, deepcopy, writeFile, build, isNonsense, exprValue, surveyFields, choicesFields, multilingualFields, pruneFalse, fieldnameConversion, typeConversion, choiceTypeConversion, dateTypeConversion, dateKindConversion, locationTypeConversion, metadataTypeConversion, appearanceNoops, appearanceConversion, rangeAppearanceConversion, mediaTypeConversion, mediaAppearanceConversion, newContext, genRange, convertQuestion, withColumn, genSettings, convertForm, serializeForm, writeForm;
  ref$ = require('prelude-ls'), isType = ref$.isType, map = ref$.map, filter = ref$.filter, foldl = ref$.foldl, join = ref$.join, flatten = ref$.flatten;
  ref$ = require('prelude-ls').Obj, keys = ref$.keys, empty = ref$.empty;
  deepcopy = require('deepcopy');
  writeFile = require('fs').writeFile;
  build = require('node-xlsx')['default'].build;
  isNonsense = function(value){
    return value == null || value === '' || (isType('Object', value) && empty(value));
  };
  exprValue = function(value){
    switch (false) {
    case value !== null:
      return "''";
    case !isType('String')(
      value):
      return "'" + value + "'";
    default:
      return value;
    }
  };
  surveyFields = ['type', 'name', 'label', 'hint', 'required', 'required_message', 'read_only', 'default', 'constraint', 'constraint_message', 'relevant', 'calculation', 'choice_filter', 'parameters', 'appearance'];
  choicesFields = ['list name', 'name', 'label'];
  multilingualFields = ['label', 'hint', 'required_message', 'constraint_message'];
  pruneFalse = ['required', 'read_only', 'range', 'length', 'count'];
  fieldnameConversion = {
    defaultValue: 'default',
    relevance: 'relevant',
    calculate: 'calculation',
    invalidText: 'constraint_message',
    readOnly: 'read_only',
    requiredText: 'required_message'
  };
  typeConversion = {};
  choiceTypeConversion = {
    inputSelectOne: 'select_one',
    inputSelectMany: 'select_multiple'
  };
  dateTypeConversion = {
    'Full Date and Time': 'dateTime',
    'Full Date': 'date',
    'Year and Month': 'date',
    'Year': 'date'
  };
  dateKindConversion = {
    'Year and Month': 'month-year',
    'Year': 'year'
  };
  locationTypeConversion = {
    'Point': 'geopoint',
    'Path': 'geotrace',
    'Shape': 'geoshape'
  };
  metadataTypeConversion = {
    'Device ID': 'deviceid',
    'Start Time': 'start',
    'End Time': 'end',
    'Today': 'today',
    'Username': 'username',
    'Subscriber ID': 'subscriberid',
    'SIM Serial': 'simserial',
    'Phone Number': 'phonenumber',
    'Start Geopoint': 'start-geopoint'
  };
  appearanceNoops = ['Default (GPS)', 'Default'];
  appearanceConversion = {
    'Show Map (GPS)': 'maps',
    'Manual (No GPS)': 'placement-map',
    'Minimal (spinner)': 'minimal',
    'Table': 'label',
    'Horizontal Layout': 'horizontal'
  };
  rangeAppearanceConversion = {
    'Vertical Slider': 'vertical',
    'Picker': 'picker'
  };
  mediaTypeConversion = {
    'Image': 'image',
    'New Image': 'image',
    'Selfie': 'image',
    'Annotate': 'image',
    'Draw': 'image',
    'Signature': 'image',
    'Audio': 'audio',
    'Video': 'video',
    'Selfie Video': 'video'
  };
  mediaAppearanceConversion = {
    'New Image': 'new',
    'Signature': 'signature',
    'Annotate': 'annotate',
    'Draw': 'draw',
    'Selfie': 'new-front',
    'Selfie Video': 'new-front'
  };
  newContext = function(){
    return {
      seenFields: {},
      choices: {},
      warnings: []
    };
  };
  genRange = function(type, range, self){
    var result, min, max;
    self == null && (self = '.');
    result = [];
    if (!isNonsense(range.min)) {
      min = type === 'inputDate'
        ? "date(" + exprValue(range.min) + ")"
        : exprValue(range.min);
      result.push(self + " >" + (range.minInclusive === true ? '=' : '') + " " + min);
    }
    if (!isNonsense(range.max)) {
      max = type === 'inputDate'
        ? "date(" + exprValue(range.max) + ")"
        : exprValue(range.max);
      result.push(self + " <" + (range.maxInclusive === true ? '=' : '') + " " + max);
    }
    return result;
  };
  convertQuestion = function(question, context, prefix){
    var choiceId, frm, ref$, too, ref1$, key, value, length, range, count, successorRelevance, other, name, i$, len$, option, res$, j$, len1$, idx, selectRange, destination, child, this$ = this;
    prefix == null && (prefix = []);
    question = deepcopy(question);
    prefix = prefix.concat([question.name]);
    choiceId = "choices_" + prefix.join('_');
    for (frm in ref$ = fieldnameConversion) {
      too = ref$[frm];
      if (question[frm] != null) {
        question[too] = (ref1$ = question[frm], delete question[frm], ref1$);
      }
    }
    for (key in question) {
      value = question[key];
      if (value === false && in$(key, pruneFalse)) {
        delete question[key];
      }
    }
    for (key in question) {
      value = question[key];
      if (isNonsense(value)) {
        delete question[key];
      }
    }
    question.constraint = question.constraint != null
      ? [question.constraint]
      : [];
    if ((length = (ref$ = question.length, delete question.length, ref$)) != null) {
      question.constraint = ((ref$ = question.constraint) != null
        ? ref$
        : []).concat("regex(., \"^.{" + length.min + "," + length.max + "}$\")");
    }
    if ((range = (ref$ = question.range, delete question.range, ref$)) != null) {
      question.constraint = ((ref$ = question.constraint) != null
        ? ref$
        : []).concat(genRange(question.type, range));
    }
    if ((count = (ref$ = question.count, delete question.count, ref$)) != null) {
      question.constraint = ((ref$ = question.constraint) != null
        ? ref$
        : []).concat(genRange(question.type, count, 'count-selected(.)'));
    }
    if (question.constraint.length === 0) {
      delete question.constraint;
    } else {
      question.constraint = join(' and ')(
      map(function(it){
        return "(" + it + ")";
      })(
      question.constraint));
    }
    if ((successorRelevance = (ref$ = context.successorRelevance, delete context.successorRelevance, ref$)) != null) {
      if (!isNonsense(successorRelevance)) {
        question.relevant = function(it){
          return it.join(' and ');
        }(
        map(function(it){
          return "(" + it + ")";
        })(
        ((ref$ = question.relevant) != null
          ? ref$
          : []).concat([successorRelevance])));
      }
    }
    if ((other = (ref$ = question.other, delete question.other, ref$)) != null) {
      context.successorRelevance = join(' or ')(
      map(function(it){
        return "selected(" + question.name + ", '" + it + "')";
      })(
      other));
    }
    if (question.cascading === true || context.cascade != null) {
      context.cascade == null && (context.cascade = []);
      question.choice_filter = (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = context.cascade).length; i$ < len$; ++i$) {
          name = ref$[i$];
          results$.push(name + " = ${" + name + "}");
        }
        return results$;
      }()).join(' and ');
      for (i$ = 0, len$ = (ref$ = question.options).length; i$ < len$; ++i$) {
        option = ref$[i$];
        res$ = {};
        for (j$ = 0, len1$ = (ref1$ = option.cascade).length; j$ < len1$; ++j$) {
          idx = j$;
          value = ref1$[j$];
          res$[context.cascade[idx]] = value;
        }
        option.cascade = res$;
      }
      context.cascade.push(question.name);
      if (question.cascading !== true) {
        delete context.cascade;
      }
      delete question.cascading;
    }
    if (question.options != null) {
      if (context.choices[choiceId] != null) {
        context.warnings = context.warnings.concat(["Multiple choice lists have the ID '" + choiceId + "'. The last one encountered is used."]);
      }
      context.choices[choiceId] = (ref$ = question.options, delete question.options, ref$);
    }
    if (in$(question.appearance, appearanceNoops)) {
      delete question.appearance;
    }
    if (appearanceConversion[question.appearance] != null) {
      question.appearance = appearanceConversion[ref$ = question.appearance, delete question.appearance, ref$];
    }
    if (question.type === 'inputDate') {
      if (dateTypeConversion[question.kind] != null) {
        question.appearance = dateKindConversion[question.kind];
      }
    }
    if (question.type === 'inputMedia' && mediaAppearanceConversion[question.kind] != null) {
      question.appearance = mediaAppearanceConversion[question.kind];
    }
    if ((ref$ = question.fieldList, delete question.fieldList, ref$) === true) {
      question.appearance = 'field-list';
    }
    question.type = question.type === 'inputNumeric'
      ? question.appearance == null || question.appearance === 'Textbox' ? (delete question.appearance, ((ref$ = (ref1$ = question.kind, delete question.kind, ref1$)) != null ? ref$ : 'integer').toLowerCase()) : 'range'
      : question.type === 'inputMedia'
        ? mediaTypeConversion[(ref$ = (ref1$ = question.kind, delete question.kind, ref1$)) != null ? ref$ : 'Image']
        : question.type === 'inputDate'
          ? dateTypeConversion[(ref$ = (ref1$ = question.kind, delete question.kind, ref1$)) != null ? ref$ : 'Full Date']
          : question.type === 'inputLocation'
            ? locationTypeConversion[(ref$ = (ref1$ = question.kind, delete question.kind, ref1$)) != null ? ref$ : 'Point']
            : question.type === 'metadata'
              ? metadataTypeConversion[(ref$ = (ref1$ = question.kind, delete question.kind, ref1$)) != null ? ref$ : 'Device ID']
              : question.type === 'group'
                ? (ref$ = question.loop, delete question.loop, ref$) === true ? 'repeat' : 'group'
                : question.type in choiceTypeConversion
                  ? choiceTypeConversion[question.type] + " " + choiceId
                  : question.type in typeConversion
                    ? typeConversion[question.type]
                    : question.type.slice(5).toLowerCase();
    if (question.type === 'range') {
      selectRange = (ref$ = question.selectRange, delete question.selectRange, ref$);
      question.parameters = {
        start: selectRange != null ? selectRange.min : void 8,
        end: selectRange != null ? selectRange.max : void 8,
        step: (ref$ = question.selectStep, delete question.selectStep, ref$)
      };
      question.appearance = rangeAppearanceConversion[ref$ = question.appearance, delete question.appearance, ref$];
      if (question.sliderTicks === false) {
        question.appearance = (((ref$ = question.appearance) != null ? ref$ : '') + ' no-ticks').trim();
      }
    }
    for (key in question) {
      value = question[key];
      if (value === true || value === false) {
        question[key] = value === true ? 'yes' : 'no';
      }
    }
    if (question.parameters != null) {
      question.parameters = (function(){
        var ref$, results$ = [];
        for (key in ref$ = question.parameters) {
          value = ref$[key];
          results$.push(key + "=" + JSON.stringify(value));
        }
        return results$;
      }()).join(' ');
    }
    for (key in question) {
      context.seenFields[key] = true;
    }
    if ((destination = (ref$ = question.destination, delete question.destination, ref$)) != null) {
      context.warnings = context.warnings.concat(["A custom xpath destination of '" + destination + "' was specified. XLSForm does not support this feature and the declaration has been dropped."]);
    }
    if (question.children != null) {
      res$ = [];
      for (i$ = 0, len$ = (ref$ = question.children).length; i$ < len$; ++i$) {
        child = ref$[i$];
        res$.push(convertQuestion(child, context, prefix));
      }
      question.children = res$;
      delete context.successorRelevance;
    }
    return question;
  };
  withColumn = function(input, header, value){
    return [input[0].concat([header]), input[1].concat([value])];
  };
  genSettings = function(form){
    var result, ref$, ref1$, ref2$, i$, ref3$, len$, attr, ref4$;
    result = [[], []];
    result = withColumn(result, 'form_title', isNonsense((ref$ = form.metadata) != null ? ref$.htitle : void 8)
      ? form.title
      : (ref1$ = form.metadata) != null ? ref1$.htitle : void 8);
    result = withColumn(result, 'form_id', ((ref2$ = form.title) != null ? ref2$.replace(/([^a-z0-9]+)/ig, '-') : void 8) + "");
    for (i$ = 0, len$ = (ref3$ = ['public_key', 'submission_url', 'instance_name']).length; i$ < len$; ++i$) {
      attr = ref3$[i$];
      if (((ref4$ = form.metadata) != null ? ref4$[attr] : void 8) != null) {
        result = withColumn(result, attr, form.metadata[attr]);
      }
    }
    if ((ref3$ = form.metadata) != null && ref3$.user_version) {
      result = withColumn(result, 'version', form.metadata.user_version);
    } else {
      result = withColumn(result, 'version', Math.floor(new Date().getTime() / 1000));
    }
    return result;
  };
  convertForm = function(form){
    var context, intermediate, res$, i$, ref$, len$, question, languages, languageNames, language, seenFields, choices, warnings, expandLanguages, genSchema, surveySchema, choicesSchema, genLang, surveySimpleFields, genRows, surveyRows, additionalChoiceCols, _, entries, key, pullCascadeValues, choicesRows, name, entry, warning, this$ = this;
    context = newContext();
    res$ = [];
    for (i$ = 0, len$ = (ref$ = form.controls).length; i$ < len$; ++i$) {
      question = ref$[i$];
      res$.push(convertQuestion(question, context));
    }
    intermediate = res$;
    languages = filter(function(it){
      return !/^_/.test(it);
    })(
    keys(
    form.metadata.activeLanguages));
    res$ = {};
    for (i$ = 0, len$ = languages.length; i$ < len$; ++i$) {
      language = languages[i$];
      res$[language] = form.metadata.activeLanguages[language];
    }
    languageNames = res$;
    seenFields = context.seenFields, choices = context.choices, warnings = context.warnings;
    expandLanguages = function(field){
      var i$, ref$, len$, language, results$ = [];
      if (in$(field, multilingualFields)) {
        for (i$ = 0, len$ = (ref$ = languages).length; i$ < len$; ++i$) {
          language = ref$[i$];
          results$.push(field + "::" + languageNames[language]);
        }
        return results$;
      } else {
        return [field];
      }
    };
    genSchema = function(seen, all){
      var this$ = this;
      return foldl(function(fields, field){
        return fields.concat(expandLanguages(field));
      }, [])(
      filter((function(it){
        return in$(it, seen);
      }))(
      all));
    };
    surveySchema = genSchema(keys(seenFields), surveyFields);
    choicesSchema = genSchema(choicesFields, choicesFields);
    genLang = function(obj){
      var i$, ref$, len$, language, results$ = [];
      for (i$ = 0, len$ = (ref$ = languages).length; i$ < len$; ++i$) {
        language = ref$[i$];
        results$.push(obj != null ? obj[language] : void 8);
      }
      return results$;
    };
    surveySimpleFields = filter((function(it){
      return in$(it, keys(seenFields));
    }))(
    surveyFields);
    genRows = function(question){
      var ref$, field;
      if (isType('Array')(
      question)) {
        return foldl(function(rows, question){
          return rows.concat(genRows(question));
        }, [])(
        question);
      } else if ((ref$ = question.type) === 'group' || ref$ === 'repeat') {
        return genRows((ref$ = clone$(question), ref$.type = "begin " + question.type, ref$)).concat(genRows(question.children), [["end " + question.type]]);
      } else {
        return [flatten(
        (function(){
          var i$, ref$, len$, results$ = [];
          for (i$ = 0, len$ = (ref$ = surveySimpleFields).length; i$ < len$; ++i$) {
            field = ref$[i$];
            if (in$(field, multilingualFields)) {
              results$.push(genLang(question[field]));
            } else {
              results$.push(question[field]);
            }
          }
          return results$;
        }()))];
      }
    };
    surveyRows = genRows(intermediate);
    additionalChoiceCols = [];
    for (_ in choices) {
      entries = choices[_];
      if (((ref$ = entries[0]) != null ? ref$.cascade : void 8) != null) {
        for (key in entries[0].cascade) {
          if (!in$(key, additionalChoiceCols)) {
            additionalChoiceCols.push(key);
          }
        }
      }
    }
    choicesSchema = choicesSchema.concat(additionalChoiceCols);
    pullCascadeValues = function(entry){
      var i$, ref$, len$, col, results$ = [];
      for (i$ = 0, len$ = (ref$ = additionalChoiceCols).length; i$ < len$; ++i$) {
        col = ref$[i$];
        results$.push(entry.cascade[col]);
      }
      return results$;
    };
    res$ = [];
    for (name in choices) {
      entries = choices[name];
      for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
        entry = entries[i$];
        res$.push([name, entry.val].concat(genLang(entry.text), pullCascadeValues(entry)));
      }
    }
    choicesRows = res$;
    return [
      {
        name: 'survey',
        data: [surveySchema].concat(surveyRows)
      }, {
        name: 'choices',
        data: [choicesSchema].concat(choicesRows)
      }, {
        name: 'settings',
        data: genSettings(form)
      }, {
        name: 'warnings',
        data: (function(){
          var i$, ref$, len$, results$ = [];
          for (i$ = 0, len$ = (ref$ = ['message'].concat(warnings != null
            ? warnings
            : ['No warnings; everything looked fine.'])).length; i$ < len$; ++i$) {
            warning = ref$[i$];
            results$.push([[warning]]);
          }
          return results$;
        }())
      }
    ];
  };
  serializeForm = curry$(function(stream, sheets){
    stream.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    stream.setHeader('Content-Disposition', 'fieldname="converted.xlsx"');
    stream.write(build(sheets));
    stream.statusCode = 200;
    return stream.end();
  });
  writeForm = curry$(function(path, sheets, callback){
    return writeFile(path, build(sheets), callback);
  });
  module.exports = {
    newContext: newContext,
    convertQuestion: convertQuestion,
    convertForm: convertForm,
    genSettings: genSettings,
    serializeForm: serializeForm,
    writeForm: writeForm
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
